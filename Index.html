<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Optimal Multi-Backend Browser</title>
<style>
  * { box-sizing: border-box; }
  body { 
    font-family: 'Segoe UI', Tahoma, sans-serif; 
    margin:0; 
    background:#0a0e27; 
    color:#fff; 
    overflow:hidden;
  }
  
  .login-overlay {
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(10,14,39,0.98);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  .login-overlay.hidden { display:none; }
  
  .login-box {
    max-width:500px;
    width:90%;
    padding:30px;
    background:#1a1f3a;
    border-radius:12px;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
  }
  .login-box h1 { 
    margin:0 0 10px 0; 
    font-size:26px;
    text-align:center;
    background:linear-gradient(135deg,#667eea,#764ba2);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
  }
  .login-box .subtitle {
    text-align:center;
    opacity:0.7;
    font-size:13px;
    margin-bottom:20px;
  }
  
  .mode-selector {
    display:grid;
    grid-template-columns:1fr 1fr;
    gap:10px;
    margin:20px 0;
  }
  .mode-card {
    background:#0f1419;
    padding:15px;
    border-radius:8px;
    border:2px solid #2d3748;
    cursor:pointer;
    transition:all 0.2s;
    text-align:center;
  }
  .mode-card:hover { border-color:#4a5de6; }
  .mode-card.selected { 
    border-color:#4ade80; 
    background:#1e3d2f;
  }
  .mode-icon {
    font-size:32px;
    margin-bottom:8px;
  }
  .mode-title {
    font-size:14px;
    font-weight:700;
    color:#fff;
    margin-bottom:5px;
  }
  .mode-desc {
    font-size:11px;
    color:#888;
  }
  .mode-badge {
    display:inline-block;
    padding:2px 6px;
    background:#4ade80;
    color:#000;
    border-radius:3px;
    font-size:9px;
    font-weight:700;
    margin-top:5px;
  }
  
  input { 
    width:100%; 
    padding:12px; 
    border-radius:8px; 
    border:1px solid #2d3748; 
    background:#0f1419;
    color:#fff;
    margin-top:8px; 
    font-size:14px;
  }
  button { 
    width:100%; 
    padding:12px; 
    border-radius:8px; 
    border:0; 
    background:#4a5de6; 
    color:#fff; 
    margin-top:12px; 
    cursor:pointer; 
    font-weight:700;
    transition: all 0.2s;
    font-size:14px;
  }
  button:hover { background:#5a6df6; transform:translateY(-1px); }
  button:disabled { background:#2d3748; cursor:not-allowed; }
  
  .status { 
    padding:10px; 
    border-radius:8px; 
    margin-top:10px; 
    display:none;
    font-size:12px;
  }
  .status.show { display:block; }
  .status.info { background:#1e3a5f; color:#60a5fa; }
  .status.success { background:#1e3d2f; color:#4ade80; }
  .status.error { background:#3d1e1e; color:#f87171; }
  
  .main-screen {
    height:100vh;
    display:flex;
    flex-direction:column;
  }
  
  .top-bar {
    background:#1a1f3a;
    padding:10px 20px;
    display:flex;
    align-items:center;
    gap:10px;
    border-bottom:2px solid #2d3748;
    flex-shrink:0;
    z-index:100;
  }
  .top-bar h1 {
    margin:0;
    font-size:16px;
    background:linear-gradient(135deg,#667eea,#764ba2);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
    white-space:nowrap;
    font-weight:900;
  }
  .url-bar {
    flex:1;
    display:flex;
    gap:8px;
  }
  .url-bar input {
    flex:1;
    margin:0;
    padding:10px;
    font-size:14px;
  }
  .url-bar button {
    width:auto;
    margin:0;
    padding:10px 20px;
    font-size:13px;
  }
  
  .stats-bar {
    display:flex;
    gap:15px;
    font-size:11px;
    color:#888;
    align-items:center;
  }
  .stat-item {
    display:flex;
    align-items:center;
    gap:5px;
  }
  .stat-value {
    color:#4ade80;
    font-weight:700;
  }
  .backend-indicators {
    display:flex;
    gap:4px;
  }
  .backend-dot {
    width:8px;
    height:8px;
    border-radius:50%;
    background:#2d3748;
  }
  .backend-dot.active { background:#4ade80; animation:pulse 2s infinite; }
  .backend-dot.primary { background:#4a5de6; box-shadow:0 0 8px #4a5de6; }
  
  @keyframes pulse {
    0%, 100% { opacity:1; }
    50% { opacity:0.5; }
  }
  
  .browser-viewport {
    flex:1;
    background:#000;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
  }
  .viewport-canvas {
    max-width:100%;
    max-height:100%;
    object-fit:contain;
    cursor:crosshair;
    box-shadow:0 0 40px rgba(0,0,0,0.8);
  }
  
  .mode-badge-corner {
    position:absolute;
    top:15px;
    right:15px;
    background:rgba(74,222,128,0.9);
    color:#000;
    padding:8px 16px;
    border-radius:8px;
    font-size:11px;
    font-weight:700;
    pointer-events:none;
    z-index:10;
    box-shadow:0 4px 12px rgba(0,0,0,0.3);
  }
  
  .debug-panel {
    position:absolute;
    bottom:15px;
    left:15px;
    background:rgba(26,31,58,0.95);
    padding:12px;
    border-radius:8px;
    font-size:10px;
    color:#888;
    max-width:300px;
    display:none;
  }
  .debug-panel.show { display:block; }
  .debug-line {
    margin:3px 0;
  }
  .debug-label {
    color:#4a5de6;
    font-weight:700;
  }
  
  .placeholder {
    color:#666;
    font-size:16px;
    text-align:center;
  }
</style>
</head>
<body>

<div class="login-overlay" id="loginOverlay">
  <div class="login-box">
    <h1>üöÄ Multi-Backend Browser</h1>
    <div class="subtitle">Intelligent distributed rendering system</div>
    
    <input id="name" placeholder="Your name" value="Alice">
    <input id="key" placeholder="Access key" type="password" value="8392017">
    
    <div class="mode-selector">
      <div class="mode-card selected" data-mode="hybrid" id="modeHybrid">
        <div class="mode-icon">‚ö°</div>
        <div class="mode-title">Hybrid</div>
        <div class="mode-desc">Best of both worlds</div>
        <div class="mode-badge">RECOMMENDED</div>
      </div>
      <div class="mode-card" data-mode="tiled" id="modeTiled">
        <div class="mode-icon">üî≤</div>
        <div class="mode-title">Tiled</div>
        <div class="mode-desc">Max parallelism</div>
      </div>
      <div class="mode-card" data-mode="redundant" id="modeRedundant">
        <div class="mode-icon">üõ°Ô∏è</div>
        <div class="mode-title">Redundant</div>
        <div class="mode-desc">High reliability</div>
      </div>
      <div class="mode-card" data-mode="roundrobin" id="modeRoundRobin">
        <div class="mode-icon">üîÑ</div>
        <div class="mode-title">Round Robin</div>
        <div class="mode-desc">Load balanced</div>
      </div>
    </div>
    
    <button id="wakeBtn" style="background:#ffd34d;color:#000">‚òï Wake All Servers</button>
    <button id="launchBtn">üöÄ Launch Browser</button>
    <div id="loginStatus" class="status"></div>
  </div>
</div>

<div class="main-screen" id="mainScreen" style="display:none">
  <div class="top-bar">
    <h1 id="topTitle">MULTI-BACKEND BROWSER</h1>
    <div class="url-bar">
      <input id="globalUrl" placeholder="Navigate to..." value="https://example.com">
      <button id="globalGo">Go</button>
      <button id="globalBack">‚Üê</button>
      <button id="globalForward">‚Üí</button>
    </div>
    
    <div class="stats-bar">
      <div class="stat-item">
        <span>FPS:</span>
        <span class="stat-value" id="fpsValue">0</span>
      </div>
      <div class="stat-item">
        <span>Latency:</span>
        <span class="stat-value" id="latencyValue">0ms</span>
      </div>
      <div class="backend-indicators" id="backendIndicators"></div>
    </div>
  </div>
  
  <div class="browser-viewport" id="browserViewport">
    <canvas id="viewportCanvas" class="viewport-canvas" width="1366" height="768"></canvas>
    <div class="mode-badge-corner" id="modeBadge">HYBRID MODE</div>
    <div class="debug-panel" id="debugPanel"></div>
  </div>
</div>

<script>
const HOST_POOL = [
  { name: "R1", url: "https://render-repo-1-yto6.onrender.com" },
  { name: "R2", url: "https://render-repo-0x73.onrender.com" },
  { name: "R3", url: "https://render-repo-f64m.onrender.com" },
  { name: "R4", url: "https://render-repo-791m.onrender.com" },
];

const VIEWPORT_WIDTH = 1366;
const VIEWPORT_HEIGHT = 768;

// System state
let backends = new Map();
let userName = "";
let renderMode = 'hybrid';
let canvas = null;
let ctx = null;

// Performance tracking
let frameStats = { count: 0, lastUpdate: Date.now() };
let latencyStats = [];

// Rendering strategies
const RenderStrategies = {
  // HYBRID: Primary backend (fastest) + tiled backups for failed regions
  hybrid: {
    init: (backends) => {
      const fastest = selectFastest(backends);
      fastest.role = 'primary';
      fastest.tileRegion = null; // Full screen
      
      const others = Array.from(backends.values()).filter(b => b !== fastest);
      assignTiles(others, true); // Assign tiles to backups
      
      return { primary: fastest, backups: others };
    },
    render: (frame, backend) => {
      if (backend.role === 'primary') {
        ctx.drawImage(frame, 0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
      } else if (backend.tileRegion) {
        // Backup tile - only draw if primary fails in this region
        const tile = backend.tileRegion;
        ctx.drawImage(frame, tile.x, tile.y, tile.width, tile.height);
      }
    }
  },
  
  // TILED: Each backend renders a vertical slice
  tiled: {
    init: (backends) => {
      assignTiles(Array.from(backends.values()), false);
      return { tiles: Array.from(backends.values()) };
    },
    render: (frame, backend) => {
      if (backend.tileRegion) {
        const tile = backend.tileRegion;
        ctx.drawImage(frame, tile.x, tile.y, tile.width, tile.height);
      }
    }
  },
  
  // REDUNDANT: All backends render full frame, use fastest
  redundant: {
    init: (backends) => {
      backends.forEach(b => {
        b.tileRegion = null; // Full screen
        b.role = 'redundant';
      });
      return { backends: Array.from(backends.values()) };
    },
    render: (frame, backend) => {
      // Always draw from fastest responding backend
      ctx.drawImage(frame, 0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
    }
  },
  
  // ROUND ROBIN: Backends take turns, increases combined FPS
  roundrobin: {
    init: (backends) => {
      const arr = Array.from(backends.values());
      arr.forEach((b, i) => {
        b.tileRegion = null;
        b.role = 'roundrobin';
        b.turnIndex = i;
      });
      return { backends: arr, currentTurn: 0 };
    },
    render: (frame, backend, state) => {
      // Only render if it's this backend's turn
      if (backend.turnIndex === state.currentTurn) {
        ctx.drawImage(frame, 0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
        state.currentTurn = (state.currentTurn + 1) % state.backends.length;
      }
    }
  }
};

let currentStrategy = null;
let strategyState = null;

function setStatus(msg, type) {
  const el = document.getElementById("loginStatus");
  el.innerHTML = msg;
  el.className = "status show " + (type || "");
}

function selectFastest(backends) {
  let fastest = null;
  let minLatency = Infinity;
  backends.forEach(backend => {
    if (backend.status === 'connected' && backend.latency < minLatency) {
      minLatency = backend.latency;
      fastest = backend;
    }
  });
  return fastest || Array.from(backends.values())[0];
}

function assignTiles(backends, isBackup) {
  const count = backends.length;
  const tileWidth = Math.floor(VIEWPORT_WIDTH / count);
  
  backends.forEach((backend, i) => {
    const x = i * tileWidth;
    const width = (i === count - 1) ? (VIEWPORT_WIDTH - x) : tileWidth;
    
    backend.tileRegion = { x, y: 0, width, height: VIEWPORT_HEIGHT };
    backend.role = isBackup ? 'backup' : 'tile';
  });
}

function initCanvas() {
  canvas = document.getElementById('viewportCanvas');
  ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
  ctx.fillStyle = '#1a1a1a';
  ctx.fillRect(0, 0, VIEWPORT_WIDTH, VIEWPORT_HEIGHT);
  
  canvas.addEventListener('click', handleClick);
  canvas.addEventListener('wheel', handleScroll, { passive: false });
}

function handleClick(e) {
  const rect = canvas.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left) * (VIEWPORT_WIDTH / rect.width));
  const y = Math.round((e.clientY - rect.top) * (VIEWPORT_HEIGHT / rect.height));
  sendCommandToAll('click', { x, y });
}

function handleScroll(e) {
  sendCommandToAll('scroll', { dy: e.deltaY });
  e.preventDefault();
}

function sendCommandToAll(action, data) {
  backends.forEach(backend => {
    if (backend.status === 'connected' && backend.ws.readyState === WebSocket.OPEN) {
      backend.ws.send(JSON.stringify({ type: 'control', action, ...data }));
    }
  });
}

function updateBackendIndicators() {
  const container = document.getElementById('backendIndicators');
  container.innerHTML = '';
  
  backends.forEach(backend => {
    const dot = document.createElement('div');
    dot.className = 'backend-dot';
    if (backend.status === 'connected') {
      dot.classList.add('active');
      if (backend.role === 'primary') dot.classList.add('primary');
    }
    dot.title = `${backend.host.name} (${backend.role || 'inactive'})`;
    container.appendChild(dot);
  });
}

function updateStats() {
  const now = Date.now();
  const elapsed = (now - frameStats.lastUpdate) / 1000;
  
  if (elapsed > 1) {
    const fps = Math.round(frameStats.count / elapsed);
    document.getElementById('fpsValue').textContent = fps;
    frameStats.count = 0;
    frameStats.lastUpdate = now;
  }
  
  if (latencyStats.length > 0) {
    const avg = Math.round(latencyStats.reduce((a, b) => a + b, 0) / latencyStats.length);
    document.getElementById('latencyValue').textContent = avg + 'ms';
    latencyStats = latencyStats.slice(-10); // Keep last 10
  }
  
  updateBackendIndicators();
}

function renderFrame(backend, imageData) {
  if (!ctx || !currentStrategy) return;
  
  const img = new Image();
  img.onload = () => {
    requestAnimationFrame(() => {
      currentStrategy.render(img, backend, strategyState);
      frameStats.count++;
    });
  };
  img.src = imageData;
}

async function connectBackend(host) {
  const wsUrl = host.url.replace(/^http/, 'ws') + '/ws';
  
  try {
    const ws = new WebSocket(wsUrl);
    ws.binaryType = 'arraybuffer';
    
    const backend = {
      ws,
      host,
      status: 'connecting',
      latency: null,
      role: null,
      tileRegion: null,
      startTime: Date.now()
    };
    
    backends.set(host.url, backend);
    
    ws.onopen = () => {
      backend.status = 'authenticating';
      ws.send(JSON.stringify({ type: 'control', action: 'create', userName }));
    };
    
    ws.onmessage = (e) => {
      if (typeof e.data === 'string') {
        const msg = JSON.parse(e.data);
        if (msg.type === 'info' && msg.action === 'created') {
          backend.status = 'connected';
          backend.latency = Date.now() - backend.startTime;
          latencyStats.push(backend.latency);
          
          // Initialize strategy if all backends connected
          const allConnected = Array.from(backends.values()).every(b => b.status === 'connected');
          if (allConnected && !currentStrategy) {
            currentStrategy = RenderStrategies[renderMode];
            strategyState = currentStrategy.init(backends);
            
            // Configure each backend based on strategy
            backends.forEach(b => {
              if (b.tileRegion) {
                b.ws.send(JSON.stringify({
                  type: 'control',
                  action: 'setViewport',
                  x: b.tileRegion.x,
                  y: b.tileRegion.y,
                  width: b.tileRegion.width,
                  height: b.tileRegion.height
                }));
              }
              b.ws.send(JSON.stringify({ type: 'control', action: 'startStream' }));
            });
          }
          
          updateStats();
        }
        return;
      }
      
      // Binary frame data
      const blob = new Blob([e.data], { type: 'image/jpeg' });
      const url = URL.createObjectURL(blob);
      renderFrame(backend, url);
      
      if (backend.lastFrameUrl) {
        setTimeout(() => URL.revokeObjectURL(backend.lastFrameUrl), 500);
      }
      backend.lastFrameUrl = url;
    };
    
    ws.onerror = () => {
      backend.status = 'error';
      updateStats();
    };
    
    ws.onclose = () => {
      backend.status = 'disconnected';
      setTimeout(() => connectBackend(host), 5000);
    };
    
  } catch (err) {
    console.error(`Failed to connect ${host.name}:`, err);
  }
}

async function validateAndLaunch() {
  const name = document.getElementById('name').value.trim();
  const key = document.getElementById('key').value.trim();
  
  if (!name || !key) {
    setStatus("‚ùå Enter credentials", "error");
    return;
  }
  
  userName = name;
  setStatus("üîç Validating...", "info");
  
  let validated = false;
  for (const host of HOST_POOL) {
    try {
      const r = await fetch(host.url + "/validate?name=" + encodeURIComponent(name) + "&key=" + encodeURIComponent(key));
      const j = await r.json();
      if (j.valid) {
        validated = true;
        break;
      }
    } catch (e) {}
  }
  
  if (!validated) {
    setStatus("‚ùå Invalid credentials", "error");
    return;
  }
  
  document.getElementById('loginOverlay').classList.add('hidden');
  document.getElementById('mainScreen').style.display = 'flex';
  
  const modeNames = {
    hybrid: 'HYBRID MODE',
    tiled: 'TILED MODE',
    redundant: 'REDUNDANT MODE',
    roundrobin: 'ROUND ROBIN'
  };
  document.getElementById('topTitle').textContent = modeNames[renderMode];
  document.getElementById('modeBadge').textContent = modeNames[renderMode];
  
  initCanvas();
  HOST_POOL.forEach(host => connectBackend(host));
}

// Mode selection
document.querySelectorAll('.mode-card').forEach(card => {
  card.addEventListener('click', () => {
    document.querySelectorAll('.mode-card').forEach(c => c.classList.remove('selected'));
    card.classList.add('selected');
    renderMode = card.dataset.mode;
  });
});

document.getElementById('wakeBtn').addEventListener('click', async () => {
  setStatus("‚òï Waking servers...", "info");
  let online = 0;
  
  const checks = HOST_POOL.map(async (host) => {
    try {
      const r = await fetch(host.url + "/health", { cache: 'no-store' });
      if ((await r.json()).status === "ok") {
        online++;
        return `‚úÖ ${host.name}`;
      }
    } catch (e) {}
    return `‚ùå ${host.name}`;
  });
  
  const results = await Promise.all(checks);
  setStatus(results.join('<br>') + `<br><br><strong>${online}/${HOST_POOL.length} online</strong>`, 
    online === HOST_POOL.length ? "success" : "info");
});

document.getElementById('launchBtn').addEventListener('click', validateAndLaunch);

document.getElementById('globalGo').addEventListener('click', () => {
  let url = document.getElementById('globalUrl').value.trim();
  if (url && !/^https?:\/\//i.test(url)) url = 'https://' + url;
  if (url) sendCommandToAll('navigate', { url });
});

document.getElementById('globalBack').addEventListener('click', () => sendCommandToAll('back', {}));
document.getElementById('globalForward').addEventListener('click', () => sendCommandToAll('forward', {}));

document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
    e.preventDefault();
    document.getElementById('globalUrl').focus();
  }
});

setInterval(updateStats, 1000);
</script>
</body>
</html>