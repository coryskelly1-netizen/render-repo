<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Parallel Multi-Backend Browser</title>
<style>
  * { box-sizing: border-box; }
  body { 
    font-family: 'Segoe UI', Tahoma, sans-serif; 
    margin:0; 
    background:#0a0e27; 
    color:#fff; 
    overflow:hidden;
  }
  
  .login-overlay {
    position:fixed;
    top:0;
    left:0;
    right:0;
    bottom:0;
    background:rgba(10,14,39,0.98);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:1000;
  }
  .login-overlay.hidden { display:none; }
  
  .login-box {
    max-width:400px;
    width:90%;
    padding:30px;
    background:#1a1f3a;
    border-radius:12px;
    box-shadow:0 20px 60px rgba(0,0,0,0.5);
  }
  .login-box h1 { 
    margin:0 0 10px 0; 
    font-size:24px;
    text-align:center;
  }
  .login-box .subtitle {
    text-align:center;
    opacity:0.7;
    font-size:13px;
    margin-bottom:20px;
  }
  input { 
    width:100%; 
    padding:12px; 
    border-radius:8px; 
    border:1px solid #2d3748; 
    background:#0f1419;
    color:#fff;
    margin-top:8px; 
    font-size:14px;
  }
  button { 
    width:100%; 
    padding:12px; 
    border-radius:8px; 
    border:0; 
    background:#4a5de6; 
    color:#fff; 
    margin-top:12px; 
    cursor:pointer; 
    font-weight:700;
    transition: all 0.2s;
    font-size:14px;
  }
  button:hover { background:#5a6df6; transform:translateY(-1px); }
  button:disabled { background:#2d3748; cursor:not-allowed; }
  
  .status { 
    padding:10px; 
    border-radius:8px; 
    margin-top:10px; 
    display:none;
    font-size:12px;
  }
  .status.show { display:block; }
  .status.info { background:#1e3a5f; color:#60a5fa; }
  .status.success { background:#1e3d2f; color:#4ade80; }
  .status.error { background:#3d1e1e; color:#f87171; }
  
  .main-screen {
    height:100vh;
    display:flex;
    flex-direction:column;
  }
  
  .top-bar {
    background:#1a1f3a;
    padding:10px 20px;
    display:flex;
    align-items:center;
    gap:10px;
    border-bottom:2px solid #2d3748;
    flex-shrink:0;
  }
  .top-bar h1 {
    margin:0;
    font-size:18px;
    background:linear-gradient(135deg,#667eea,#764ba2);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
    white-space:nowrap;
    font-weight:900;
  }
  .url-bar {
    flex:1;
    display:flex;
    gap:8px;
  }
  .url-bar input {
    flex:1;
    margin:0;
    padding:10px;
    font-size:14px;
  }
  .url-bar button {
    width:auto;
    margin:0;
    padding:10px 20px;
    font-size:13px;
  }
  
  .backend-status {
    display:flex;
    gap:8px;
    align-items:center;
    margin-left:auto;
    font-size:11px;
  }
  .backend-pill {
    padding:4px 10px;
    border-radius:999px;
    background:#2d3748;
    white-space:nowrap;
    display:flex;
    align-items:center;
    gap:4px;
  }
  .backend-pill.active { 
    background:linear-gradient(135deg,#1e3d2f,#2d5a3f); 
    color:#4ade80;
    animation: pulse-glow 2s ease-in-out infinite;
  }
  .backend-pill.error { background:#3d1e1e; color:#f87171; }
  
  @keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 5px rgba(74,222,128,0.3); }
    50% { box-shadow: 0 0 15px rgba(74,222,128,0.6); }
  }
  
  .browser-container {
    flex:1;
    display:flex;
    flex-direction:column;
    padding:20px;
    overflow:hidden;
  }
  
  .browser-viewport {
    flex:1;
    background:#000;
    border-radius:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:crosshair;
    position:relative;
    overflow:hidden;
    border:3px solid #2d3748;
    box-shadow:0 10px 40px rgba(0,0,0,0.5);
  }
  .browser-viewport.streaming { 
    border-color:#4ade80; 
    box-shadow:0 0 30px rgba(74,222,128,0.3), 0 10px 40px rgba(0,0,0,0.5);
  }
  .browser-viewport img {
    width:100%;
    height:100%;
    object-fit:contain;
    display:block;
  }
  .browser-viewport .placeholder {
    color:#666;
    font-size:16px;
    text-align:center;
  }
  
  .info-panel {
    margin-top:15px;
    display:grid;
    grid-template-columns:repeat(auto-fit, minmax(200px, 1fr));
    gap:10px;
  }
  .info-card {
    background:#1a1f3a;
    padding:15px;
    border-radius:8px;
    border:1px solid #2d3748;
  }
  .info-label {
    font-size:11px;
    color:#888;
    text-transform:uppercase;
    margin-bottom:5px;
  }
  .info-value {
    font-size:20px;
    font-weight:700;
    background:linear-gradient(135deg,#667eea,#764ba2);
    -webkit-background-clip:text;
    -webkit-text-fill-color:transparent;
    background-clip:text;
  }
  .info-detail {
    font-size:12px;
    color:#aaa;
    margin-top:3px;
  }
  
  .backend-list {
    margin-top:8px;
  }
  .backend-item {
    font-size:11px;
    padding:4px 0;
    display:flex;
    justify-content:space-between;
    align-items:center;
  }
  .backend-name { 
    color:#4a5de6; 
    display:flex;
    align-items:center;
    gap:5px;
  }
  .backend-fps {
    color:#4ade80;
    font-weight:700;
  }
  .backend-latency { color:#888; }
  
  .frame-indicator {
    display:inline-block;
    width:6px;
    height:6px;
    border-radius:50%;
    background:#4ade80;
    animation: blink 0.5s ease-in-out infinite;
  }
  
  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.3; }
  }
  
  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
  }
  .loading {
    animation: pulse 2s ease-in-out infinite;
  }
</style>
</head>
<body>

<div class="login-overlay" id="loginOverlay">
  <div class="login-box">
    <h1>‚ö° Parallel Browser</h1>
    <div class="subtitle">Multiple backends working together for maximum FPS</div>
    
    <input id="name" placeholder="Your name" value="Alice">
    <input id="key" placeholder="Access key" type="password" value="8392017">
    
    <button id="wakeBtn" style="background:#ffd34d;color:#000">‚òï Wake All Servers</button>
    <button id="launchBtn">üöÄ Launch Parallel Browser</button>
    <div id="loginStatus" class="status"></div>
  </div>
</div>

<div class="main-screen" id="mainScreen" style="display:none">
  <div class="top-bar">
    <h1>‚ö° PARALLEL BROWSER</h1>
    <div class="url-bar">
      <input id="globalUrl" placeholder="Navigate to..." value="https://example.com">
      <button id="globalGo">Go</button>
      <button id="globalBack">‚Üê</button>
      <button id="globalForward">‚Üí</button>
      <button id="globalRefresh">üîÑ</button>
    </div>
    <div class="backend-status" id="backendStatus"></div>
  </div>
  
  <div class="browser-container">
    <div class="browser-viewport" id="browserViewport" tabindex="0">
      <div class="placeholder loading">Initializing parallel rendering...</div>
    </div>
    
    <div class="info-panel">
      <div class="info-card">
        <div class="info-label">Combined FPS</div>
        <div class="info-value" id="fps">0</div>
        <div class="info-detail" id="fpsDetail">Parallel rendering inactive</div>
      </div>
      <div class="info-card">
        <div class="info-label">Total Bandwidth</div>
        <div class="info-value" id="bandwidth">0</div>
        <div class="info-detail">KB/s across all backends</div>
      </div>
      <div class="info-card">
        <div class="info-label">Parallel Workers</div>
        <div class="info-value" id="workerCount">0/0</div>
        <div class="backend-list" id="backendList"></div>
      </div>
      <div class="info-card">
        <div class="info-label">Frame Distribution</div>
        <div class="info-value" id="frameDistribution">-</div>
        <div class="info-detail" id="distributionDetail">Round-robin scheduling</div>
      </div>
    </div>
  </div>
</div>

<script>
// Backend server pool
const HOST_POOL = [
  { name: "Render-1", url: "https://render-repo-1-yto6.onrender.com" },
  { name: "Render-2", url: "https://render-repo-0x73.onrender.com" },
  { name: "Render-3", url: "https://render-repo-f64m.onrender.com" },
];

let backends = new Map(); // hostUrl -> { ws, host, status, latency, frameCount, lastFrameTime, fps }
let userName = "";
let lastFrame = null;
let totalFrameCount = 0;
let totalBytesReceived = 0;
let lastStatsUpdate = Date.now();

// Frame buffer for smooth playback
let frameBuffer = [];
let maxBufferSize = 10;
let isPlaying = false;

function setStatus(msg, type) {
  const el = document.getElementById("loginStatus");
  el.innerHTML = msg;
  el.className = "status show " + (type||"");
}

function updateBackendPills() {
  const container = document.getElementById('backendStatus');
  container.innerHTML = '';
  
  const connected = Array.from(backends.values()).filter(b => b.status === 'connected');
  
  connected.forEach((backend, idx) => {
    const pill = document.createElement('div');
    pill.className = 'backend-pill';
    
    if (backend.status === 'connected') {
      pill.className += ' active';
      pill.innerHTML = `<span class="frame-indicator"></span>${backend.host.name} (${backend.fps || 0} fps)`;
    }
    
    container.appendChild(pill);
  });
}

function updateStats() {
  const connected = Array.from(backends.values()).filter(b => b.status === 'connected');
  const total = backends.size;
  
  document.getElementById('workerCount').textContent = `${connected.length}/${total}`;
  
  // Calculate individual backend FPS
  const now = Date.now();
  backends.forEach((backend, url) => {
    if (backend.frameCount > 0 && backend.lastStatsUpdate) {
      const elapsed = (now - backend.lastStatsUpdate) / 1000;
      if (elapsed > 1) {
        backend.fps = Math.round(backend.frameCount / elapsed);
        backend.frameCount = 0;
        backend.lastStatsUpdate = now;
      }
    }
  });
  
  // Update backend list with individual stats
  const list = document.getElementById('backendList');
  list.innerHTML = '';
  backends.forEach((backend, url) => {
    const item = document.createElement('div');
    item.className = 'backend-item';
    const status = backend.status === 'connected' ? 'üü¢' : 'üî¥';
    item.innerHTML = `
      <span class="backend-name">${status} ${backend.host.name}</span>
      <span class="backend-fps">${backend.fps || 0} fps</span>
    `;
    list.appendChild(item);
  });
  
  // Calculate combined FPS and bandwidth
  const elapsed = (now - lastStatsUpdate) / 1000;
  if (elapsed > 1) {
    const combinedFps = Math.round(totalFrameCount / elapsed);
    const kbps = Math.round((totalBytesReceived / 1024) / elapsed);
    
    document.getElementById('fps').textContent = combinedFps;
    document.getElementById('fpsDetail').textContent = `${connected.length} backends rendering in parallel`;
    document.getElementById('bandwidth').textContent = `${kbps} KB/s`;
    
    // Calculate frame distribution
    const perBackend = connected.length > 0 ? Math.round(combinedFps / connected.length) : 0;
    document.getElementById('frameDistribution').textContent = `~${perBackend} fps`;
    document.getElementById('distributionDetail').textContent = `per backend (${connected.length}x multiplier)`;
    
    totalFrameCount = 0;
    totalBytesReceived = 0;
    lastStatsUpdate = now;
  }
  
  updateBackendPills();
}

// Frame display with buffering for smooth playback
function displayNextFrame() {
  if (frameBuffer.length > 0) {
    const frame = frameBuffer.shift();
    
    const viewport = document.getElementById('browserViewport');
    viewport.innerHTML = `<img src="${frame}" alt="Browser">`;
    viewport.classList.add('streaming');
    
    // Cleanup old frame
    if (lastFrame && lastFrame !== frame) {
      setTimeout(() => URL.revokeObjectURL(lastFrame), 1000);
    }
    lastFrame = frame;
  }
  
  // Continue playback loop
  requestAnimationFrame(displayNextFrame);
}

function sendCommand(action, data) {
  // Send command to ALL backends - they all stay in sync
  let sent = 0;
  backends.forEach((backend, url) => {
    if (backend.status === 'connected' && backend.ws.readyState === WebSocket.OPEN) {
      backend.ws.send(JSON.stringify({type:'control', action, ...data}));
      sent++;
    }
  });
  
  if (sent === 0) {
    console.warn('No backends available to send command');
  }
}

async function connectBackend(host) {
  const wsUrl = host.url.replace(/^http/, 'ws') + '/ws';
  
  try {
    const ws = new WebSocket(wsUrl);
    ws.binaryType = 'arraybuffer';
    
    const backendData = {
      ws: ws,
      host: host,
      status: 'connecting',
      latency: null,
      frameCount: 0,
      lastFrameTime: null,
      lastStatsUpdate: Date.now(),
      fps: 0,
      startTime: Date.now()
    };
    
    backends.set(host.url, backendData);
    
    ws.onopen = () => {
      console.log(`‚úÖ Connected to ${host.name}`);
      backendData.status = 'authenticating';
      ws.send(JSON.stringify({type:'control', action:'create', userName: userName}));
    };
    
    ws.onmessage = (e) => {
      if (typeof e.data === 'string') {
        try {
          const j = JSON.parse(e.data);
          if (j.type === 'info' && j.action === 'created') {
            backendData.status = 'connected';
            backendData.latency = Date.now() - backendData.startTime;
            console.log(`‚úÖ ${host.name} authenticated (${backendData.latency}ms)`);
            
            // Start streaming immediately
            ws.send(JSON.stringify({type:'control', action:'startStream'}));
            
            // Start frame display loop if not already running
            if (!isPlaying) {
              isPlaying = true;
              displayNextFrame();
            }
            
            updateStats();
          }
          if (j.type === 'error') {
            console.error(`Error from ${host.name}:`, j.message);
            backendData.status = 'error';
            updateStats();
          }
        } catch (err) {}
        return;
      }
      
      // Handle frame from ANY backend - all frames are used!
      const blob = new Blob([e.data], { type: 'image/jpeg' });
      const url = URL.createObjectURL(blob);
      
      // Add to frame buffer (bounded to prevent memory issues)
      if (frameBuffer.length < maxBufferSize) {
        frameBuffer.push(url);
      } else {
        // Buffer full, drop oldest frame
        const oldFrame = frameBuffer.shift();
        URL.revokeObjectURL(oldFrame);
        frameBuffer.push(url);
      }
      
      // Update stats
      backendData.frameCount++;
      backendData.lastFrameTime = Date.now();
      totalFrameCount++;
      totalBytesReceived += e.data.byteLength;
      
      if (!backendData.lastStatsUpdate) {
        backendData.lastStatsUpdate = Date.now();
      }
      
      updateStats();
    };
    
    ws.onerror = (err) => {
      console.error(`Connection error: ${host.name}`);
      backendData.status = 'error';
      updateStats();
    };
    
    ws.onclose = () => {
      console.log(`Disconnected: ${host.name}`);
      backendData.status = 'disconnected';
      updateStats();
      
      // Auto-reconnect after 5 seconds
      setTimeout(() => {
        console.log(`Reconnecting to ${host.name}...`);
        connectBackend(host);
      }, 5000);
    };
    
  } catch (err) {
    console.error(`Failed to connect to ${host.name}:`, err);
  }
}

async function validateAndLaunch() {
  const name = document.getElementById('name').value.trim();
  const key = document.getElementById('key').value.trim();
  
  if (!name || !key) {
    setStatus("‚ùå Enter name and key", "error");
    return;
  }
  
  userName = name;
  setStatus("üîç Validating credentials...", "info");
  
  // Validate with first available host
  let validated = false;
  for (const host of HOST_POOL) {
    try {
      const r = await fetch(host.url + "/validate?name=" + encodeURIComponent(name) + "&key=" + encodeURIComponent(key));
      const j = await r.json();
      if (j.valid) {
        validated = true;
        break;
      }
    } catch (e) {
      continue;
    }
  }
  
  if (!validated) {
    setStatus("‚ùå Invalid credentials", "error");
    return;
  }
  
  // Hide login, show main screen
  document.getElementById('loginOverlay').classList.add('hidden');
  document.getElementById('mainScreen').style.display = 'flex';
  
  // Connect to ALL backends - they all contribute frames in parallel!
  for (const host of HOST_POOL) {
    connectBackend(host);
  }
  
  updateStats();
}

// Wake servers button
document.getElementById('wakeBtn').addEventListener('click', async () => {
  setStatus("‚òï Waking all servers...", "info");
  
  let online = 0;
  let offline = 0;
  
  const checks = HOST_POOL.map(async (host) => {
    try {
      const r = await fetch(host.url + "/health", { cache: 'no-store' });
      const j = await r.json();
      if (j.status === "ok") {
        online++;
        return `‚úÖ ${host.name}: Online`;
      } else {
        offline++;
        return `‚ö†Ô∏è ${host.name}: Not OK`;
      }
    } catch (e) {
      offline++;
      return `‚ùå ${host.name}: Offline (cold start)`;
    }
  });
  
  const results = await Promise.all(checks);
  const summary = results.join('<br>');
  
  setStatus(`<strong>Server Status:</strong><br>${summary}<br><br><strong>Online: ${online} / ${HOST_POOL.length}</strong>`, 
    online === HOST_POOL.length ? "success" : (online > 0 ? "info" : "error"));
});

// Event listeners
document.getElementById('launchBtn').addEventListener('click', validateAndLaunch);

document.getElementById('globalGo').addEventListener('click', () => {
  let url = document.getElementById('globalUrl').value.trim();
  if (url) {
    if (!/^https?:\/\//i.test(url)) {
      url = 'https://' + url;
    }
    sendCommand('navigate', { url });
  }
});

document.getElementById('globalBack').addEventListener('click', () => {
  sendCommand('back', {});
});

document.getElementById('globalForward').addEventListener('click', () => {
  sendCommand('forward', {});
});

document.getElementById('globalRefresh').addEventListener('click', () => {
  const url = document.getElementById('globalUrl').value.trim();
  if (url) {
    sendCommand('navigate', { url });
  }
});

// Viewport interactions
const viewport = document.getElementById('browserViewport');

viewport.addEventListener('click', (e) => {
  if (e.target.tagName !== 'IMG') return;
  
  const img = e.target;
  const rect = img.getBoundingClientRect();
  const x = Math.round((e.clientX - rect.left) * (1366 / rect.width));
  const y = Math.round((e.clientY - rect.top) * (768 / rect.height));
  
  sendCommand('click', { x, y });
  viewport.focus();
});

viewport.addEventListener('keydown', (e) => {
  if (e.key.length === 1) {
    sendCommand('type', { text: e.key });
    e.preventDefault();
  } else if (e.key === 'Enter') {
    sendCommand('type', { text: '\n' });
    e.preventDefault();
  } else if (e.key === 'Backspace') {
    sendCommand('type', { text: '\b' });
    e.preventDefault();
  }
});

viewport.addEventListener('wheel', (e) => {
  sendCommand('scroll', { dy: e.deltaY });
  e.preventDefault();
}, { passive: false });

// Global keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === 'l') {
    e.preventDefault();
    document.getElementById('globalUrl').focus();
    document.getElementById('globalUrl').select();
  }
  
  if ((e.ctrlKey || e.metaKey) && e.key === 'r') {
    e.preventDefault();
    document.getElementById('globalRefresh').click();
  }
});

// Auto-focus viewport on load
setTimeout(() => {
  viewport.focus();
}, 1000);

// Stats update loop
setInterval(updateStats, 1000);
</script>
</body>
</html>